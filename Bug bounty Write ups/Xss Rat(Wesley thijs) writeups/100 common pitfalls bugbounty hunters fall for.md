
100 common mistakes bugbounty hunters make:



1. Ignoring Program Scope

2. Testing Outside the Allowed Domains

3. Using Automated Scanners Without Proper Customization

4. Submitting Low-Impact Bugs

5. Filing Bugs Without Clear Reproducibility

6. Exploiting Bugs that Don’t Have a Security Impact

7. Not Understanding the Program's Rules

8. Ignoring Rate-Limiting or Session Timeouts

9. Assuming a Vulnerability Exists Based on Assumptions

10. Disclosing Bugs Publicly Before Program Resolution

11. Failure to Use Proper Ethical Hacking Techniques

12. Rushing Submissions Without Proper Testing

13. Submitting Fuzzing-Generated Results Without Analysis

14. Assuming That the Program Doesn’t Have “Known Issues”

15. Not Respecting the Responsible Disclosure Guidelines

16. Not Understanding the Legal Implications

17. Assuming All Vulnerabilities Are Critical

18. Ignoring Local Privilege Escalation Potential

19. Failing to Validate Input Thoroughly

20. Reusing Exploit Code from Other Vulnerabilities

21. Misidentifying False Positives as Bugs

22. Testing Without Proper Consent in Programs that Require It

23. Not Reporting Interactions with Third-Party Services

24. Using Multiple Accounts to Submit the Same Bug

25. Failing to Test for Same-Origin Policy Violations

26. Disregarding Authorization Flaws in Third-Party APIs

27. Submitting Duplicate Vulnerabilities

28. Missing Edge Case Scenarios

29. Ignoring HTTP Headers for Security Misconfigurations

30. Overlooking CSRF and Session Management Flaws

31. Assuming Every Parameter Can Be Exploited

32. Using an Outdated Version of Tools for Testing

33. Failure to Validate Reported Bugs Against Latest Software Versions

34. Not Testing Across All Browsers or Platforms

35. Ignoring Cookie Attributes (Secure, HttpOnly, SameSite)

36. Overlooking SSL/TLS Configuration Issues

37. Not Testing for DNS Rebinding Vulnerabilities

38. Exploiting Bugs Too Aggressively in Production

39. Neglecting to Check for Password Hashing Weaknesses

40. Forgetting to Check for Insecure File Uploads

41. Neglecting to Perform Manual Testing Alongside Automated Tools

42. Not Reviewing Other Researchers’ Reports for Overlaps

43. Reporting Bugs without Clear Proof of Concept

44. Submitting Insufficient Details for Reproducibility

45. Exploiting a Vulnerability Without Prior Authorization

46. Not Using Secure Testing Environments

47. Testing Without Taking Proper Backup Precautions

48. Assuming a Vulnerability is Specific to One Platform Only

49. Not Checking for Multi-Factor Authentication Flaws

50. Failing to Test for Insecure Direct Object References (IDOR)

51. Not Considering Impact Beyond Data Theft (Denial of Service, etc.)

52. Ignoring Business Logic Vulnerabilities

53. Submitting Bugs in Duplicate Report Categories

54. Overlooking Potential for Denial of Service (DoS) Attacks

55. Misunderstanding the Severity of Bugs




56. Overlooking Subtle User-Driven Security Flaws

57. Exploiting Non-Security Related Bugs Just for the Prize

58. Failing to Use Latest Security Tools and Techniques

59. Disregarding Patch Management Issues

60. Not Considering Insufficient Logging or Monitoring in Attack Scenarios

61. Submitting Issues in Non-Critical Code Paths

62. Disregarding the Bounty Program’s Terms and Conditions on Rewards





63. Not Taking Steps to Avoid Locking Yourself Out of the Application

64. Submitting Reports in Poor Format or Unclear Language

65. Failing to Provide Full Impact Assessment for a Vulnerability

66. Ignoring Browser Caching and Configuration Flaws

67. Submitting Bugs Without Considering the Business Context

68. Forgetting About Platform-Specific Weaknesses (e.g., mobile)

69. Submitting Bugs Without Explaining the Exploit Path

70. Not Considering Legacy Systems in Security Testing

71. Assuming an App is Secure Just Because It’s Behind a Firewall

72. Failing to Test for Insecure Cryptographic Storage

73. Not Considering Time-of-Check Time-of-Use (TOCTOU) Issues

74. Not Using Proper Network Analysis Tools

75. Reporting Bugs Without Context on User Roles

76. Failing to Test for Error Messages Leaking Sensitive Information

77. Assuming No Vulnerabilities Exist Because No Vulnerabilities Were Found During Scanning




78. Reporting Bugs Too Late in the Program

79. Assuming All API Calls Require Authentication

80. Filing Bugs That Are a Result of User Error (Usability Issues)

81. Not Checking for Cross-Domain Scripting Issues

82. Failing to Verify the Context of the Vulnerability

83. Using Unnecessary Complex Exploits

84. Assuming a Patch Fixes the Vulnerability for All Cases

85. Not Validating the Fix Implemented by the Program

86. Reporting Known Bugs Already in the Public Domain

87. Exploiting Bugs in Production Environments Without a Plan

88. Ignoring Rate Limiting and CAPTCHA Mechanisms

89. Submitting Bugs Without Testing Under Different User Roles

90. Not Trying to Exploit Bugs with Different Attack Vectors

91. Failing to Assess API Security Risks

92. Not Considering the Full Attack Surface of an Application

93. Filing Bugs in Areas that Are Not Part of the Program Scope

94. Submitting Bugs Without Proper Validation

95. Ignoring Third-Party Service Integrations for Vulnerabilities

96. Forgetting to Test Subdomains or Less-Critical Areas

97. Test Cases Being Too Generic or Vague

98. Using Illegal or Harmful Testing Tools

99. Failing to Check for Lack of Input Validation

100. Exploiting Bugs That Are Not Real or Are Fixable by Simple Configurations